/*
 * This code blinks the LED connected to P1.0 using an interrupt generated by the timer module
 *
 * We use the Timer0 module in CONTINUOUS mode to count from 0 to 0xFFFF and back to 0
 * Everytime the counter "overflows" to zero, an interrupt is generated and it is used to
 * toggle the LED
 *
 * We could use the Timer in UP mode and then the TACCR0 register to have finer control of the period
 * We could also use the clock divider on the Timer0 module to extend the period of switching
 * (Or we can implement the same with more control by using a variable as a counter, in software)
 *
 */

#include <msp430.h> 

int main(void) {
    WDTCTL = WDTPW | WDTHOLD;	// Stop watchdog timer
	
    P1DIR|=BIT0; //Set P1.0 as output pin

    TACTL|=TASSEL_2+MC_2+TAIE; //Start Timer0 with SMCLK clock source, Continuous mode and enable overflow interrupt

    __low_power_mode_0();//Go into low power mode 0

	return 0;
}

#pragma vector=TIMER0_A1_VECTOR
__interrupt void TMR0()
{
    if(TAIV==TA0IV_TAIFG)   //Check if Timer overflow caused the interrupt
                            //This would be required in projects where multiple interrupts have
                            //the same interrupt vector. Here it is only optional.
        {
            P1OUT^=BIT0; //Toggle the LED
            TACTL&=~(TAIFG); //Reset the interrupt flag
        }
}
